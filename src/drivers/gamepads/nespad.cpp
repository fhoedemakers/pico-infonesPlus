#include <pico/stdlib.h>
#include "hardware/pio.h"
#include "gamepads.h"

// It seams from my personal tests that using bitbanging driver works better then
// by using pio and nespad_read_start / nespad_read_finish or nespad_read sequences.
// For eg in Bubble Bobble not every jump are detected when I press the button.
#define USE_NESPAD_PIO 0

#if USE_NESPAD_PIO == 0

void nespad_init(void){
  gpio_init(NES_PIN_LAT);
  gpio_set_function(NES_PIN_LAT, GPIO_FUNC_SIO);
  gpio_set_dir(NES_PIN_LAT, GPIO_OUT);
  gpio_put(NES_PIN_LAT, false);

  gpio_init(NES_PIN_CLK);
  gpio_set_function(NES_PIN_CLK, GPIO_FUNC_SIO);
  gpio_set_dir(NES_PIN_CLK, GPIO_OUT);
  gpio_put(NES_PIN_CLK, false);

  gpio_init(NES_PIN_DATA);
  gpio_set_function(NES_PIN_DATA, GPIO_FUNC_SIO);
  gpio_set_dir(NES_PIN_DATA, GPIO_IN);
  gpio_pull_up(NES_PIN_DATA);

  gpio_init(NES_PIN_DATA2);
  gpio_set_function(NES_PIN_DATA2, GPIO_FUNC_SIO);
  gpio_set_dir(NES_PIN_DATA2, GPIO_IN);
  gpio_pull_up(NES_PIN_DATA2);

  printf("Nespad bitbang driver initialized.\n");
}

// True table for PolyStation pads:
//   Note: X/Y/Z/C seams to be different sequeces of bits and 0.
//   Different mapping from http://www.gamesx.com/controldata/snesdat.htm
//
// Keys:  | A/X/C B/Y/Z Select Start Up Down Left Right A X L  R  N/A N/A N/A N/A
// Bits:  | 0     1     2      3     4  5    6    7     8 9 10 11 12  13  14  15
// Value: | 1     2     4      8     16 32   64   128

void nespad_read(void){
  uint8_t curr_data[2] = {0};
  static uint8_t prev_data[2] = {0};

  // Use the same logic like in nespad.pio
  // Latch high, 12 uS total.
  gpio_put(NES_PIN_LAT, true);
  sleep_us(12);
  // Latch low.
  gpio_put(NES_PIN_LAT, false);

  for(int i = 0; i < 8; i++){
    // Read bit on falling clock or latch, wait 6 uS.
    curr_data[0] |= ((~gpio_get(NES_PIN_DATA) & 1) << i);
    curr_data[1] |= ((~gpio_get(NES_PIN_DATA2) & 1) << i);
    sleep_us(6);
    // Clock high, wait for 6 uS.
    gpio_put(NES_PIN_CLK, true);
    sleep_us(6);
    // Clock low, repeat for 8 bits.
    gpio_put(NES_PIN_CLK, false);
  }

  for (int i = 0; i < 2; ++i){
    auto &gp = io::getCurrentGamePadState(i);
    // Only set once gb.buttons if new data arrive in this driver.
    // This logic is needed to avoid clearing gp.buttons value that can be already set by other gamepad in the system.
    if (prev_data[i] != curr_data[i]){
      prev_data[i] = curr_data[i];
      gp.buttons = \
        (curr_data[i] & 1 << 0 ? io::GamePadState::Button::A : 0)
      | (curr_data[i] & 1 << 1 ? io::GamePadState::Button::B : 0)
      | (curr_data[i] & 1 << 2 ? io::GamePadState::Button::SELECT : 0)
      | (curr_data[i] & 1 << 3 ? io::GamePadState::Button::START : 0)
      | (curr_data[i] & 1 << 4 ? io::GamePadState::Button::UP : 0)
      | (curr_data[i] & 1 << 5 ? io::GamePadState::Button::DOWN : 0)
      | (curr_data[i] & 1 << 6 ? io::GamePadState::Button::LEFT : 0)
      | (curr_data[i] & 1 << 7 ? io::GamePadState::Button::RIGHT : 0);
      // printf("nespad_read set new data: %d\n", gp.buttons);
    }
  }
  // if (data[0] > 0 || data[1] > 0){
  //   printf("val1: %d - val2: %d\n", data[0], data[1]);
  // }
}

void nespad_close(void){
  printf("Nespad bitbang driver closed.\n");
}

#else

static PIO pio = pio0;
static uint8_t sm = -1;

#define nespad_wrap_target 0
#define nespad_wrap 6

// Generated by https://wokwi.com/tools/pioasm
static const uint16_t nespad_program_instructions[] = {
          //     .wrap_target
  0xc020, //  0: irq    wait 0          side 0c
  0xea01, //  1: set    pins, 1         side 0 [10]
  0xe027, //  2: set    x, 7            side 0
  0xe000, //  3: set    pins, 0         side 0
  0x4401, //  4: in     pins, 1         side 0 [4]
  0xf500, //  5: set    pins, 0         side 1 [5]
  0x0044, //  6: jmp    x--, 4          side 0
          //     .wrap
};

static const struct pio_program nespad_program = {
  .instructions = nespad_program_instructions,
  .length = nespad_wrap+1,
  .origin = -1,
};

static inline pio_sm_config nespad_program_get_default_config(uint offset){
  pio_sm_config c = pio_get_default_sm_config();
  sm_config_set_wrap(&c, offset + nespad_wrap_target, offset + nespad_wrap);
  sm_config_set_sideset(&c, 1, false, false);
  return c;
}

// TODO: Add support for second controler.
void nespad_init(void){
  uint32_t cpu_khz=252000;

  if (pio_can_add_program(pio, &nespad_program) && ((sm = pio_claim_unused_sm(pio, true)) >= 0))
  {
    uint offset = pio_add_program(pio, &nespad_program);
    pio_sm_config c = nespad_program_get_default_config(offset);

    sm_config_set_sideset_pins(&c, NES_PIN_CLK);
    sm_config_set_in_pins(&c, NES_PIN_DATA);
    sm_config_set_set_pins(&c, NES_PIN_LAT, 1);

    pio_gpio_init(pio, NES_PIN_CLK);
    pio_gpio_init(pio, NES_PIN_DATA);
    // pio_gpio_init(pio, NES_PIN_DATA2);
    pio_gpio_init(pio, NES_PIN_LAT);

    gpio_set_pulls(NES_PIN_DATA, true, false); // Pull data high, 0xFF if unplugged
    // gpio_set_pulls(NES_PIN_DATA2, true, false); // Pull data high, 0xFF if unplugged

    pio_sm_set_pindirs_with_mask(pio, sm,
      (1 << NES_PIN_CLK) | (1 << NES_PIN_LAT), // Outputs
      (1 << NES_PIN_CLK) | (1 << NES_PIN_LAT) | (1 << NES_PIN_DATA) // All pins
    );

    sm_config_set_in_shift(&c, true, true, 8); // R shift, autopush @ 8 bits
    // sm_config_set_in_shift(&c, false, true, 24),

    sm_config_set_clkdiv_int_frac(&c, cpu_khz / 1000, 0); // 1 MHz clock

    // IRQ is just a 'go' flag, don't assert a system interrupt
    pio_set_irq0_source_enabled(pio, (pio_interrupt_source)(pis_interrupt0 + sm), false);

    pio_sm_clear_fifos(pio, sm);

    pio_sm_init(pio, sm, offset, &c);
    pio_sm_set_enabled(pio, sm, true);

    printf("Nespad pio driver initialized.\n");
  } else {
    printf("Cannot initialize nespad pio driver.\n");
  }
}


// Initiate nespad read. Non-blocking; result will be available in ~100 uS
// via nespad_read_finish(). Must first call nespad_begin() once to set up PIO.
void nespad_read_start(void) { pio_interrupt_clear(pio, 0); }

// Finish nespad read. Ideally should be called ~100 uS after
// nespad_read_start(), but can be sooner (will block until ready), or later
// (will introduce latency). Sets value of global nespad_state variable, a
// bitmask of button/D-pad state (1 = pressed). 0x01=Right, 0x02=Left,
// 0x04=Down, 0x08=Up, 0x10=Start, 0x20=Select, 0x40=B, 0x80=A. Must first
// call nespad_begin() once to set up PIO. Result will be 0 if PIO failed to
// init (e.g. no free state machine).
// void nespad_read_finish(void) {
//   // Right-shift was used in sm config so bit order matches NES controller
//   // bits used elsewhere in picones, but does require shifting down...
//   nespad_state = (sm >= 0) ? ((pio_sm_get_blocking(pio, sm) >> 24) ^ 0xFF) : 0;
// }

void nespad_read(void){
  // uint32_t data = pio_sm_get_blocking(pio, sm);
  // uint8_t pin0_state = (data >> 0) & 0xFF;
  // uint8_t pin1_state = (data >> 8) & 0xFF;
  // uint8_t pin2_state = (data >> 16) & 0xFF;

  // if (pin0_state != 255){
  //   printf("Pin 0 state: %d (%02x)\n", pin0_state, pin0_state);
  // }
  // if (pin1_state != 255){
  //   printf("Pin 1 state: %d (%02x)\n", pin1_state, pin1_state);
  // }
  // if (pin2_state != 255){
  //   printf("Pin 2 state: %d (%02x)\n", pin2_state, pin2_state);
  // }

  // Determine if a state machine's RX FIFO is empty.
  if (pio_sm_is_rx_fifo_empty(pio, sm)){
    if (pio_interrupt_get(pio, 0)){
      pio_interrupt_clear(pio, 0);
    }
  } else {
    // Read a word of data from a state machine's RX FIFO.
    uint8_t nespad_state = (sm >= 0) ? ((pio_sm_get(pio, sm) >> 24) ^ 0xFF) : 0;

    // Read a word of data from a state machine's RX FIFO, blocking if the FIFO is empty.
    // uint8_t nespad_state = (sm >= 0) ? ((pio_sm_get_blocking(pio, sm) >> 24) ^ 0xFF) : 0;
    auto &gp = io::getCurrentGamePadState(0);
    gp.buttons |= \
      (nespad_state & 1 << 0 ? io::GamePadState::Button::A : 0)
    | (nespad_state & 1 << 1 ? io::GamePadState::Button::B : 0)
    | (nespad_state & 1 << 2 ? io::GamePadState::Button::SELECT : 0)
    | (nespad_state & 1 << 3 ? io::GamePadState::Button::START : 0)
    | (nespad_state & 1 << 4 ? io::GamePadState::Button::UP : 0)
    | (nespad_state & 1 << 5 ? io::GamePadState::Button::DOWN : 0)
    | (nespad_state & 1 << 6 ? io::GamePadState::Button::LEFT : 0)
    | (nespad_state & 1 << 7 ? io::GamePadState::Button::RIGHT : 0);

    // if (nespad_state > 0){
    //   printf("nespad_state: %d\n", nespad_state);
    // }
  }
}

#endif